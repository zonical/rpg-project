#include "rpg/rpg.h"

namespace fs = std::filesystem;

void Tileset::FreeTiles()
{
    for (auto& tile : tiles)
    {
        EngineResources.textures.RemoveTexture(tile.texture);
    }
    EngineResources.textures.RemoveTexture(texture);
}

void TilesetManager::Initalize()
{
    std::string path = "assets/tiles";
    for (const auto& entry : fs::recursive_directory_iterator(path))
    {
        // Get the path as a string.
        std::string path = entry.path().string();

        // Replace the slashes in our path with forward slashes.
        int stringIndex;
        while ((stringIndex = path.find("\\")) != std::string::npos)
        {
            path.replace(stringIndex, std::string("/").length(), std::string("/"));
        }

        // We only load JSON files. This check is here as folders count under the iterator
        // and we obviously can't load a folder.
        if (path.ends_with(".json")) LoadTileset(path);
    }
}

Tileset TilesetManager::GetTileset(std::string tilesetPath)
{
    // Double check to see if this tileset exists.
    if (!TilesetExists(tilesetPath)) return {};

    // Find our tileset with the tileset path.
    auto iter = tilesets.find(tilesetPath);
    return iter->second;
}

bool TilesetManager::TilesetExists(std::string tilesetPath)
{
    // Find our tileset with the tileset path.
    auto iter = tilesets.find(tilesetPath);
    return !(iter == tilesets.end());
}

bool TilesetManager::RemoveTileset(std::string tilesetPath)
{
    // Double check to see if this tileset exists.
    if (!TilesetExists(tilesetPath)) return false;

    // Get the tileset from our map of tilesets.
    Tileset tileset = GetTileset(tilesetPath);
    
    tileset.FreeTiles();

    // Remove this tileset from the map.
    tilesets.erase(tilesetPath);
    return true;
}

void TilesetManager::ReleaseAllTilesets()
{
    // Loop through all of our tilesets and release them.
    for (std::map<std::string, Tileset>::iterator iter = tilesets.begin();
        iter != tilesets.end(); iter++)
    {
        iter->second.FreeTiles();
    }
}

bool TilesetManager::LoadTileset(std::string tilesetPath)
{
    // The file we're loading is a tileset information file generated by Tiled.
    // This will hold the image file we need to reference here.
    using json = nlohmann::json;
    auto tilesetData = GameEngine->LoadJSON(tilesetPath);

    // Grab the image source and the width and height of the image.
    auto imageWidth = tilesetData["imagewidth"].get<int>();
    auto imageHeight = tilesetData["imageheight"].get<int>();
    auto imageSource = tilesetData["image"].get<std::string>();

    // Quickly modify our image source so we can find it in /assets/tiles
    imageSource = "assets/tiles/" + imageSource;
    
    // Load the texture into our texture manager.
    EngineResources.textures.LoadTexture(imageSource);

    // If this tileset already exists in our map, remove it first, and then
    // put in this new tileset.
    if (TilesetExists(imageSource))
    {
        // Remove it.
        RemoveTileset(imageSource);
    }

    // Grab our tile information. A tile might have extra information such as collision
    // baked into it, and we'll lump it with our TileData later on.
    auto tilesData = tilesetData["tiles"].get<std::vector<json>>();

    // Start constructing our tileset.
    Tileset tileset;
    tileset.texture = imageSource;

    // Construct our tileset. The size for each tile in our tileset is a 64x64 rectangle.
    // We read strictly from left to right and then top to bottom.
    int yIterations = floor(imageHeight / 64);
    int xIterations = floor(imageWidth / 64);

    // Because 0 internally in Tiled as treated as "no tile", we need to create a completely
    // blank texture that we can use as a placeholder. This file should NOT be deleted.
    TileData blankTileData;
    blankTileData.texture = "assets/tile/_internalBlankTile.png";
    tileset.tiles.push_back(blankTileData);

    int tileNum = 0;

    for (int y = 0; y < yIterations; y++)
    {
        for (int x = 0; x < xIterations; x++)
        {
            // Construct a tile.
            TileData tile;
            tile.rect.x = 64 * x;
            tile.rect.y = 64 * y;
            tile.texture = imageSource;

            // Grab our tile data. We'll grab stuff like collision objects associated
            // with this tile here.
            auto tileObjData = tilesData[tileNum].get<json>();

            // If we have the "objectgroup" key, we can deal with objects such as collision.
            if (tileObjData.contains("objectgroup"))
            {
                // Grab our object data.
                auto objectgroup = tileObjData["objectgroup"].get<json>();

                // Grab our objects and start iterating over them.
                for (auto object : objectgroup["objects"].get<std::vector<json>>())
                {
                    // Are we a collision rectangle?
                    if (object["type"].get<std::string>() == "collision_rect")
                    {
                        // Construct a new rectangle and fill it in with our information.
                        SDL_FRect rect;
                        rect.w = object["width"].get<float>();
                        rect.h = object["height"].get<float>();
                        rect.x = object["x"].get<float>();  // Top left from the tile.
                        rect.y = object["y"].get<float>();  // Top left from the tile.
                        
                        tile.collisionRects.push_back(rect);
                    }
                }
            }

            // Add our tile ot the tileset.
            tileset.tiles.push_back(tile);
            tileNum++;
        }
    }

    // Store this new tileset in our map.
    tilesets.insert(std::pair<std::string, Tileset>(tilesetPath, tileset));
    std::cout << "[TILESETS] Tileset with " << tileset.tiles.size() << " tiles loaded: " << tilesetPath.c_str() << std::endl;
    return true;
}